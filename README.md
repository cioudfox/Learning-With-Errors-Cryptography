### Linear-Equation-Cryptography
Lua code that encrypts a message using Linear Equations w/ Offset in relation to Lattice Based Cryptography

## 1) Generate the Private Key/ Alphabet
Take any 4 integer values, these values correspond to a solution set for some system of linear equations. This key is private information.
The Alphabet can be anything, in this program, the alphabet is the 26 letters in the english alphabet.

## 2) Generate the list of equation w/ offset
Generate a large list of linear equations and apply a random offset to its summation. This modification should make it unlikely for a non-singular partition of equations to have a solution. Then modulus this value to a large prime value to allow for modular arithmetic. 

## 3) Encode a Message
Take a partition of equations and add them together and formulate a new equation and ensure right hand side summation is still modulated to the same large prime value. This program uses a selection of 5 equations each iteration. 

Calculate the location of the character in correlation to the large prime used in the modulus. For instance, 523 can be split into 26 different parts into 20 with integer division. Take this estimate distance and multiple it to the corresponding letter number encoding. The letter "D" corresponds with 80 (4 * 20).

From the partition, take the right hand summation and add that to the location of the character and modulus by large prime. 

## 4) Decoding the Message
Using the key, plug in the private key into the equation to solve for accurate RHS summation value. 

Subtract the encoded partition summation with the accurate RHS summation value. Then solve for value by performing integer division in respect to distance calculations in encoding. 


## Why it works?
Before the offset is added in, it is possible to solve all generated equations with the private key. Similarly, the private key can still solve for a combination of any partition of the equation set. An offset and distance value is generated by the by the formulas below.

### Distance = (Large Prime) // (# of Character Indexes)
### Offset < (Distance) / (# of Variables)

A random value generated between 0 and Offset will guarantee an offset will never be more than the distance value away from the original. The randomized offset makes it impossible for a subset of equations to be solved by the private key, similarly, all combined partitions are not solutions anymore either. This list of equations w/ offset is used as the public key.

Due to the randomized offset, it is impossible to know how much offset each equation has on the right hand side even after combining the equations which makes it difficult to solve for the private key without any further information given. The summation of the equations are modulated to some prime number to allow for indexing. 

For encoding, selecting a random subset of equations to combine and adding the distance value to the right hand side sum. The sum must continue to be modulated in terms of the large prime to preserve indexing. 

For decoding, the private key can solve for the actual right hand side solution. Subtracting the encoded right hand side sum from the actual value will retreive both the distance and offset values. Since the offset is less than the distance, performing integer division on this difference will retreive the distance value and index of the character sent.
